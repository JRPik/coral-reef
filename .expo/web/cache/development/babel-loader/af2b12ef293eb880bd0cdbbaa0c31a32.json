{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\n\nvar AnimationContainer = function (_React$Component) {\n  _inherits(AnimationContainer, _React$Component);\n\n  var _super = _createSuper(AnimationContainer);\n\n  function AnimationContainer(props) {\n    var _this;\n\n    _classCallCheck(this, AnimationContainer);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"animation\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"animatedValuesByKey\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"interpolationsByKey\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"startAnimation\", function () {\n      _this.animation.start();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"stopAnimation\", function () {\n      _this.animation.reset();\n\n      for (var key in _this.animatedValuesByKey) {\n        _this.animatedValuesByKey[key].setValue(0);\n      }\n    });\n\n    var initAnimation = props.initAnimation;\n    var animationInitializersByKey = initAnimation();\n    var animations = [];\n\n    for (var key in animationInitializersByKey) {\n      var animationInitializer = animationInitializersByKey[key];\n      var animationValue = new Animated.Value(0);\n      _this.animatedValuesByKey[key] = animationValue;\n\n      var _animationInitializer = animationInitializer(animationValue),\n          animation = _animationInitializer.animation,\n          values = _animationInitializer.values;\n\n      animations.push(animation);\n      _this.interpolationsByKey[key] = values;\n    }\n\n    if (animations.length === 1) {\n      _this.animation = animations[0];\n    } else {\n      _this.animation = Animated.parallel(animations);\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimationContainer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.animating) {\n        this.startAnimation();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var animating = this.props.animating;\n\n      if (animating !== prevProps.animating) {\n        if (animating) {\n          this.startAnimation();\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.animation.stop();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children ? children(this.interpolationsByKey) : null;\n    }\n  }]);\n\n  return AnimationContainer;\n}(React.Component);\n\nexport { AnimationContainer as default };\n\n_defineProperty(AnimationContainer, \"defaultProps\", {\n  animating: true\n});","map":{"version":3,"sources":["AnimationContainer.tsx"],"names":["AnimationContainer","React","animating","constructor","initAnimation","animationInitializersByKey","animations","animationInitializer","animationValue","Animated","values","componentDidMount","componentDidUpdate","prevProps","componentWillUnmount","render","children"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;;;IAgBe,kB;;;;;AAiBbG,8BAAW,KAAXA,EAA6B;AAAA;;AAAA;;AAC3B,8BAAA,KAAA;;AAD2B,IAAA,eAAA,gCAAA,WAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,gCAAA,qBAAA,EAboB,EAapB,CAAA;;AAAA,IAAA,eAAA,gCAAA,qBAAA,EANzB,EAMyB,CAAA;;AAAA,IAAA,eAAA,gCAAA,gBAAA,EAyCZ,YAAM;AACrB,YAAA,SAAA,CAAA,KAAA;AA1C2B,KAAA,CAAA;;AAAA,IAAA,eAAA,gCAAA,eAAA,EA6Cb,YAAM;AACpB,YAAA,SAAA,CAAA,KAAA;;AAEA,WAAK,IAAL,GAAA,IAAkB,MAAlB,mBAAA,EAA4C;AAC1C,cAAA,mBAAA,CAAA,GAAA,EAAA,QAAA,CAAA,CAAA;AACD;AAlD0B,KAAA,CAAA;;AAE3B,QAAQC,aAAR,GAAA,KAAA,CAAQA,aAAR;AAEA,QAAMC,0BAA0B,GAAGD,aAAnC,EAAA;AACA,QAAME,UAAyC,GAA/C,EAAA;;AAEA,SAAK,IAAL,GAAA,IAAA,0BAAA,EAA8C;AAC5C,UAAMC,oBAAoB,GAAGF,0BAA0B,CAAvD,GAAuD,CAAvD;AACA,UAAMG,cAAc,GAAG,IAAIC,QAAQ,CAAZ,KAAA,CAAvB,CAAuB,CAAvB;AACA,YAAA,mBAAA,CAAA,GAAA,IAAA,cAAA;;AACA,kCAA8BF,oBAAoB,CAAlD,cAAkD,CAAlD;AAAA,UAAM,SAAN,yBAAM,SAAN;AAAA,UAAmBG,MAAnB,yBAAmBA,MAAnB;;AACAJ,MAAAA,UAAU,CAAVA,IAAAA,CAAAA,SAAAA;AACA,YAAA,mBAAA,CAAA,GAAA,IAAA,MAAA;AACD;;AAED,QAAIA,UAAU,CAAVA,MAAAA,KAAJ,CAAA,EAA6B;AAC3B,YAAA,SAAA,GAAiBA,UAAU,CAA3B,CAA2B,CAA3B;AADF,KAAA,MAEO;AACL,YAAA,SAAA,GAAiBG,QAAQ,CAARA,QAAAA,CAAjB,UAAiBA,CAAjB;AACD;;AApB0B;AAqB5B;;;;WAEDE,6BAAoB;AAClB,UAAI,KAAA,KAAA,CAAJ,SAAA,EAA0B;AACxB,aAAA,cAAA;AACD;AACF;;;WAEDC,4BAAkB,SAAlBA,EAAwC;AACtC,UAAQV,SAAR,GAAsB,KAAtB,KAAA,CAAQA,SAAR;;AAEA,UAAIA,SAAS,KAAKW,SAAS,CAA3B,SAAA,EAAuC;AACrC,YAAA,SAAA,EAAe;AACb,eAAA,cAAA;AADF,SAAA,MAEO;AACL,eAAA,aAAA;AACD;AACF;AACF;;;WAcDC,gCAAuB;AACrB,WAAA,SAAA,CAAA,IAAA;AACD;;;WAEDC,kBAAS;AACP,UAAQC,QAAR,GAAqB,KAArB,KAAA,CAAQA,QAAR;AACA,aAAOA,QAAQ,GAAGA,QAAQ,CAAC,KAAZ,mBAAW,CAAX,GAAf,IAAA;AACD;;;;EA3EOf,KAAK,CAFA,S;;SAAA,kB;;gBAAMD,kB,kBAaG;AACpBE,EAAAA,SAAS,EAAE;AADS,C","sourcesContent":["import * as React from 'react'\nimport { Animated } from 'react-native'\n\ninterface AnimationNode {\n  animation: Animated.CompositeAnimation\n  values: Animated.AnimatedInterpolation[]\n}\n\nexport interface Props<T extends string> {\n  initAnimation: () => Record<T, (value: Animated.Value) => AnimationNode>\n  children: (\n    interpolationsByKey: Record<T, Animated.AnimatedInterpolation[]>\n  ) => React.ReactNode\n  animating: boolean\n}\n\nexport default class AnimationContainer<\n  T extends string\n> extends React.Component<Props<T>> {\n  animation: Animated.CompositeAnimation\n  animatedValuesByKey: Record<T, Animated.Value> = {} as Record<\n    T,\n    Animated.Value\n  >\n  interpolationsByKey: Record<\n    T,\n    Animated.AnimatedInterpolation[]\n  > = {} as Record<T, Animated.AnimatedInterpolation[]>\n\n  static defaultProps = {\n    animating: true,\n  }\n\n  constructor(props: Props<T>) {\n    super(props)\n    const { initAnimation } = props\n\n    const animationInitializersByKey = initAnimation()\n    const animations: Animated.CompositeAnimation[] = []\n\n    for (const key in animationInitializersByKey) {\n      const animationInitializer = animationInitializersByKey[key]\n      const animationValue = new Animated.Value(0)\n      this.animatedValuesByKey[key] = animationValue\n      const { animation, values } = animationInitializer(animationValue)\n      animations.push(animation)\n      this.interpolationsByKey[key] = values\n    }\n\n    if (animations.length === 1) {\n      this.animation = animations[0]\n    } else {\n      this.animation = Animated.parallel(animations)\n    }\n  }\n\n  componentDidMount() {\n    if (this.props.animating) {\n      this.startAnimation()\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const { animating } = this.props\n\n    if (animating !== prevProps.animating) {\n      if (animating) {\n        this.startAnimation()\n      } else {\n        this.stopAnimation()\n      }\n    }\n  }\n\n  startAnimation = () => {\n    this.animation.start()\n  }\n\n  stopAnimation = () => {\n    this.animation.reset()\n\n    for (const key in this.animatedValuesByKey) {\n      this.animatedValuesByKey[key].setValue(0)\n    }\n  }\n\n  componentWillUnmount() {\n    this.animation.stop()\n  }\n\n  render() {\n    const { children } = this.props\n    return children ? children(this.interpolationsByKey) : null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}